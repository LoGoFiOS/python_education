# Вторая неделя
Язык интерпретируемый с некоторой [компиляцией](https://habr.com/ru/post/209812/ "компиляцией"). **CPython** – самая распространённая реализация, написанная на **C**, компилирует исходный код в **байткод**, а затем интерпретирует его, запуская на виртуальной машине. Более подробно об устройстве [CPython](https://habr.com/ru/company/yandex/blog/511972/ "CPython").


## Модель данных
В Python всё – объекты и отношения между ними. Здесь объект это абстракция (контейнер в памяти) для данных. 

Каждый объект хранит информацию:  идентификатор, тип и значение.
Идентификатор **id(x)** – адрес объекта **x** в памяти. 

Запись **y = 42** означает, что имя **y** связывается с объектом **42**, т.е. ссылается на него. Поэтому значение переменной – значение объекта по ссылке.

```python
х  = [1, 2, 3]     # создались 4-ре объекта в памяти: список и числа
y = x    # y ссылается на х, который ссылается на объект list
y is x    # True
```


## Стандартные типы данных
Типы данных делятся на **Mutable** (изменяемые) и  **Immutable** (неизменяемые). 

**Mutable**: числа, bool, tuple(), string, frozenSet.
**Immutable**: list[], dict{}, set{}

**Mutable** могут менять своё значение в течение жизненного цикла. 

```python
s = "123"
t = s
t is s # True
t = t + "4"
print(s, t) # "123", "1234"
t is s # False

x = [1,2,3]
y = x
y is x # True
y.append(4)
y is x # True
print(x, y) # [1,2,4,4] [1,2,3,4]
```

Так же важно различать операторы **=** и **+=**, применяемых к **mutable**:

```python
x = [1,2,3]
y = x
y += [5]
x is y # True. x и y ссылаются на один объект
z = x + [5]
x is z # False. Был создан новый объект, на который ссылается z
```

  

## Функции. Общее
Функции также являются объектами.

```python
def fun_name(arg1, arg2): # (1)
    return arg1+arg2 # (3)(4)
    
x = fun_name(8,2) # (2)
y = fun_name(x, 21)
```

1. При объявлении функции создаётся объект с которым связывается имя функции **fun_name.**
2. Создаются объекты **8** и **2** на которые ссылаются **arg1** и **arg2**.
3. Создаётся объект с результатом – **10**.
4. Ссылка на этот объект – результат выполнения функции. При этом важно, что если функция не имеет явного **return**, то результатом будет **None**.

**Важно!** Если заданы аргументы по-умолчанию, то они будут вычислены 1 раз – при объявлении функции:

```python
b = 1
def foo(a=b):
    print(a)
    
foo() # out: 1
b = 2
foo() # out: 1
```

Здесь дважды вызывается один и тот же mutable **list**, созданный при объявлении функции:

```python
def foo(x=[0]):
    x[0] += 1
    print(x)
    
foo() # out 1
foo() # out 2
```


##  Стек вызовов
Каждая вызываемая функция помещается в **стек вызовов**, который работает по принципу **LIFO**. В основе стека всегда лежит **module** – функция, исполняющая запросы, создающая объекты. 

Все функции "выполняются", но ожидают завершения вышележащей функции.

```python
def h():
    print(42)
    
def f():
    g(h)
    
def g(a):
    a()
    
g(f)
```

Стек, на момент вызова **print**, будет выглядеть: 

```python
module -> g() -> f() -> g() -> h() -> print()
```


## Функции. Аргументы
Аргументы функциям должны передаваться следующим образом:

```python
def fun(позиционные элементы,
    позиционные аргументы со стандартным значением,
    кортеж элементов (*args),
    обязательные keyword_only,
    словарь аргументов (**kwargs))
```

За счёт ***args** и ***\*kwargs** можно передавать неопределённое количество аргументов. Все позиционные аргументы "уйдут" в кортеж ***args**, а именованные в словарь ***\*kwargs**. 

При вызове функций можно передавать все значения кортежа и словаря, распаковывая их:

```python
def foo(a, b, *args, c=10):
    print (a, b, c, args) # 1 2 10 (100, 200, 300)
    
tip = (100, 200, 300)
foo(1, 2,*tip, c=10)
```


## Пространство имён (namespaces)
Это множество ссылок от имён до объектов.

При запуске интерпретатора создаётся пространство имён **buitins**, где находятся стандартные имена Python (int, str, max, pow и тд).

Ниже по иерархии расположено пространство имён **main**, в котором определены все глобальные переменные.

Когда вызывается функция – создаётся локальное пространство имён. После завершения функции он уничтожается. Имена в области функции и глобальной могут повторяться:

```python
t_c = 18
tmp = 'OK'
def calc(t_c):
    tmp = t_c*9/5
    return tmp+32
    
print(calc(t_c)) # 64,4 (1)
print(tmp) # OK
```

Важно отметить, что в (1) в стек вызовов попадает сначала **calc**, а затем **print**. Почему? Код читается программой справа-налево. Т.е. интерпретатор должен сначала понять, что он вызывается для **print**.


##  Области видимости (Scopes)
Правило для поиска имён **LEGB: local -> enclosing -> global -> builtins**
**local** – внутри функции
**enclosing** – до последних закрывающих функций. Т.е. если имеем несколько вложений функций друг в друга, то **enclosing** дойдёт до самого верхнего уровня:

```python
def a():
val = 42
def b():
    def c():
        def d():
            print(val)
        d()
    c()
b()

a()
```

Чтобы не париться из-за **scope** можно передавать переменные в качестве аргументов.
**Важно** переменные, объявленные в цикле в функции, остаются доступны в функции и после завершения цикла.

Интересные примеры:

Локальная переменная, созданная при вызове функции, ссылается на не инициализированную саму себя:

```python
value = 100
def foo():
    value = value + 10
    print(value)
    
foo() # Error
```

Пример правильной работы:

```python
value = 100
def foo():
    loc_value = value + 10
    print(loc_value)
    
foo() # 110
print(value) # 100
```

Ещё один. Здесь локальная **value** инициализируется за счёт передачи аргумента:

```python
value = 100
def foo(value):
    value = value + 10
    print(value)
    
foo(value) # 110
print(value) # 100
```

Пример того, как в теле функции можно изменить глобальную переменную. **ПЛОХОЙ ПОДХОД!**

```python
value = 100
def foo():
    global value = value + 10
    print(value)
    
foo(value) # 110
print(value) # 110
```

В чём разница между пространством имён и областью видимостью? **Scopes** определяет области, откуда доступны определённые имена. Scopes реализован через **словарь**, сопоставляющий имена с объектами. Эти словари и являются **namespaces**.


##  Классы. Общее
Класс – механизм создания собственного типа данных. Существуют объекты класса, его экземпляров и связанных методов.

В отличии от функций, тело класса исполняется в момент его определения. В этот же момент создаётся его **namespace**.

В классе существуют **атрибуты** - имена, к которым можно обратиться через **.**. Атрибуты можно добавлять в течение жизненного цикла:

```python
 class Counter:
    pass
    
 x = Counter()
 x.count = 0
 x.count += 1
```

## Классы. Конструктор

```python
class Counter:
    def __init__(self): # (1)(2)(3)
        self.count = 0
        
x = Counter() # (4)
print(x.count) # 0
```

1. При определении класса создаётся пустой объект класса (без атрибутов, namespace пуст). 
2. Этот объект передаётся как **self** в конструктор **__init__**.
3. **__init__** возвращает **None**, т.к. эта функция призвана устанавливать атрибуты для объекта **self**.
4. Таким образом, **x** ссылается на изменённый внутри конструктора **self**.

## Классы. Связанные методы
Это специальный объект, связывающий объект с функцией класса.

```python
class Counter:  #(1)
    def __init__(self):
        self.count = 0    
        
    def inc(self):
        self.count += 1
        
    def reset(self):
        self.count = 0
        
x = Counter() # (2)
x.inc() # (3)
```

1. При определении класса **Counter** создаётся namespace (**\__init__**, **inc**, **reset**)
2. Объекту **x**, в результате работы конструктора, был добавлен атрибут **count** в namespace. 
3. В namespace объекта **x** нет имени **inc**, но есть в классе. Как же экземпляр **x** получает доступ к нему? Дело в том, что **x.inc()** – связанный метод. Запись **x.inc() == Counter.inc(x)** говорит о том, что **Counter.inc(x)** связалась с **x**.  

Пример с атрибутами общими для всех и индивидуальных для каждого экземпляра:

```python
class A:
    val = 1
    def foo(self):
        A.val += 2
    
    def bar(self):
        self.val += 1
        
a = A()
b = A()
a.bar()
a.foo()
c = A()
print(a.val) # 2
print(b.val) # 3
print(c.val) # 3
```

## Классы. Наследование
Экземпляр класса может вести себя как экземпляр любого класса предка. 

Полезными методами являются:
1) **issubclass(A, B)** – проверка является ли класс **A** потомком класса **B**?
2) **isinstance(A, B)** – Может ли объект **A** использоваться в качестве объекта **B**?
3) **.mro()** – порядок разрешения методов. Полезно при множественном наследовании. 

Нужно ли лезть под капот алгоритма порядка разрешения методов? Думаю, что нет. Можно почитать об этом у Лучано Рамальо в "Python. К вершинам мастерства".

## Ошибки и исключения
Ошибка это объект, хранящая стек вызовов. Ошибки можно отлавливать несколькими способами:

```python
try:
    code
except TypeError:
    code
except ZeroDivisionError:
    code
....
```

 Как только вылавливается ошибка, далее проверка не идёт. Если необходимо выполнить код после ошибки, то нужно добавить **finally**:
```python
 try:
    code
except TypeError:
    code
except ZeroDivisionError:
    code
finally:
    code
```

Ошибки могут быть записаны в один кортеж. Конструкция **as** позволит обратиться к ошибке:

```python
 try:
    code
except (TypeError, ZeroDivisionError) as e: # e - объект ошибки
    print(type(e))
    ....
```

Можно создать свой класс ошибок, который **должен** наследоваться от **Exception**:

```python
class NonPositiveError(Exception):
    pass

class PositiveList(list):
    def append(self, x):
        if x > 0:
            super().append(x)
        else:
            raise NonPositiveError(f"{x} < 0!")
```

## Импорт
Когда пишем **import module**, то файл с **module** исполняется. Те имена, которые остаются в результате выполнения мы сможем импортировать. 

Иногда необходимо, чтобы выполнялся не весь код при импортировании. Можно воспользоваться проверкой if **name == "_\_main__"**. Это условие будет выполняться только тогда, когда модуль будет выполняться в качестве самостоятельного скрипта, а не в качестве импортированного модуля. 

**Важно**. Любой модуль исполняется лишь единожды. Он помещается в словарь **sys.modules**. При повторном импортировании возвращается объект из этого словаря. 

```python
main.py
import module1 import module2
print(3)

module1.py
import module2
print(1)

module2.py
print(2)

#out 2 1 3
```

Конструкция **from *module* import *name1, name2...*** позволяет вытаскивать из модуля только определённые имена, избегая конфликтов. 

**import module -> обращение module.name
from module import name -> обращение name**

## Итераторы и генераторы
Итератор – объект перечислитель, возвращающий по 1 объекту за раз. Ниже показано, как работает итератор: 

```python
lst = [1, 2, 3]

for i in lst:
	print(i)

it = iter(lst)
while True:
	try:
		i = next(it)
		print(i)
	except StopIteration:
		break
```


Можно писать собственные итераторы, определяя "магические" методы **_\_iter_\_, _\_next_\_**. Но проще пользоваться генераторами (для экономии памяти), т.к. генераторы не хранят все данные.

Генераторы позволяют использовать концепцию "отложенного исполнения" - функция будет продолжена тогда, когда это потребуется. Исполнение тела функции происходит, когда вызывается метод **next** (вызывая явно или при обращении к генератору, как к любой функции). Происходит от одного **yield** до следующего. Если не найдено, то ошибка **StopIteration**.

Подробнее стоит почитать здесь: https://habr.com/ru/post/132554/

Так же стоит помнить про создание списков через **list comprehension**:

```python
z = [(x, y) for x in range(3) for y in range(3) if y >= x]
# [(0, 0), (0, 1), (0, 2), (1, 1), (1, 2), (2, 2)]
```

Если же заменить **[]** на **()**, то получим **генератор**:

```python
z = ((x, y) for x in range(3) for y in range(3) if y >= x)
```

## Файловая система и файлы

Два типа файлов: текстовые и бинарные.

Режимов работы с файлами несколько. Полезные **"r"** – read, **"w"** – write (содержимое стирается) и **"a"** – append (добавить в конец). По-умолчанию работаем с текстовым файлом. Если бинарный, то нужно добавить **"b"** – **"rb"** и тд.

Открывая файлы с помощью **with** мы гарантируем, что файл будет закрыт в случае ошибки. Можно открывать несколько файлов:

```python
with open("test.txt") as f, open("test_copy.txt", "w") as w:
	...
```

Модуль **os.path** позволяет выводить папки и файлы, проверять является ли объект папкой или файлом, менять директорию и пр.

Так же есть функция **os.walk,** рекурсивно проходящая по папкам и являющаяся генератором. Каждое обращение – возвращение кортежа (строковое представление директории, список всех подпапок тек. дир., список файлов в тек. дир.):

```python
for current_dir, dirs, files in os.walk("."):
	...
```

## Functool и лямбда функции

**Map** – итератор, т.к. возвращает объект-итератор и применяет к нему первый аргумент-функцию. 

Конструктор **filter** возвращает filter-object, являющийся итератором.

**Lambda** – функции одного выражения.

**Operator** - полезная библиотека для вычислений. Интересно **itemgetter** – возвращающая объект по индексу. 

**Functool** - полезная библиотека. Здесь интересна **partial** – функция, запоминающая аргументы для вызываемых функций:

```python
from functools import partial

x = int("1101", base=2)
print(x) # 13
int_2 = partial(int, base=2)
x = int_2("1101")
print(x) # 13
```

##  Стиль программирования

Стоит придерживаться правил **PEP8** для лучшего понимания кода. 

# Третья неделя

## Стандартные методы и функции для строк

Документацию можно читать как официальном сайте, так и вызывая **_\_ doc__** для методов, например, **s.replace._\_ doc__** ( здесь s - объект string).

```python
# Проврека вхождения
print("abc" in "abcac") # True

# Индекс первого вхождения с позиции pos. -1, если не найдено
"cabcs".find("abc", pos)

# Индекс первого вхождения или ValueError
"cabcs".index("abc")

# Проверка первых и последних символов
s = "image.png"
s.startswith("image") # True
s.endswith("png") # True

s.count("aba") # Число непересекающихся значений
s.lower() # Перевод в нижний регистр
s.upper() # Перевод в верхний регистр
s.replace("a", "x") # замена а на х
s.split(", ") # разделяет строку на список. Если неуказан разделитель, то убираются все пробелы.

numbers = map(str, [1, 2, 3, 4])
print(repr(" ".join(numbers)))


```

Отдельно стоит [изучить](https://shultais.education/blog/python-f-strings) вывод строк через **format()**. 

## Регулярные выражения

Регулярные выражения описывают шаблон, по которому проверяется подходит ли строка под этот шаблон.

"Сырые" строки **row** позволяют выводить символы, даже если они являются специальными: 

```python
print("\tHello\n World")
print(r"\tHello\nWorld") # print \tHello\nWorld
```

Для работы с регулярными выражениями используется модуль **re**.

re.match – Проверка (**в начале строки**), подходит ли данная строка под данный шаблон. Если нет, то возвращает **None**. 

re.search – Находит первую строку, которая подходит под шаблон.

```python
pattern = r"abc"
string = "babc"
math_object = re.match(pattern, string) # None
math_object = re.search(pattern, string) # span=(1, 4)
```

re.findall – Находит все подстроки, которые подходят под шаблон.

re.sub – Заменяет все вхождения подходящих строк на что-нибудь другое. 

Чтобы найти символ, относящийся к мета символам, нужно его экранировать через **\\**:

```python
pattern = r" english\?"
string = "Do you speak english?"
math_object = re.search(pattern, string) # span=(12, 21)
```

**Важно!** Мета символы повторов (**+**) по-умолчанию являются **жадными**, т.е. возвращают максимально возможную строку:

```python
pattern = r"a[ab]+a"
string = "abaaba"
print(re.match(pattern, string)) # span=(0, 6) match = abaaba
print(re.findall(pattern, string)) # abaaba
```

Чтобы искать не жадным методом, можно использовать **?**:

```python
pattern = r"a[ab]+?a"
string = "abaaba"
print(re.match(pattern, string)) # span=(0, 3) match = aba
print(re.findall(pattern, string)) # [aba, aba]
```



