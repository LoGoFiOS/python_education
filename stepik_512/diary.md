# Язык Python. Общее
Язык интерпретируемый с некоторой [компиляцией](https://habr.com/ru/post/209812/ "компиляцией"). CPython - самая распространённая реализация, написанная на C, компилирует исходный код в байткод, а затем интерпретирует его, запуская на виртуальной машине. Более подробно об устройстве [CPython](https://habr.com/ru/company/yandex/blog/511972/ "CPython").


## Модель данных
В Python всё - объекты и отношения между ними. Здесь объект это абстракция (контейнер в памяти) для данных. 

Каждый объект хранит:  идентификатор, тип и значение.
Идентификатор `id(x)`- адрес объекта `x` в памяти. 

Когда пишем `y  =  42`, то это означает, что имя `y` связывается с объектом `42`, т.е. ссылается на него. Поэтому значение переменной - значение объекта по ссылке.

    х  = [1, 2, 3]     # создались 4-ре объекта в памяти: список и числа
    y = x    # y ссылается на х, который ссылается на объект list
    y is x    # True


## Стандартные типы данных
Типы данных делятся на Mutable (изменяемые) и  Immutable (неизменяемые). 

Mutable: числа, bool, tuple(), string, frozenSet.
Immutable: list[], dict{}, set{}

Mutable могут менять своё значение в течение жизненного цикла. 

    s = "123"
    t = s
    t is s # True
    t = t + "4"
    print(s, t) # "123", "1234"
    t is s # False

    x = [1,2,3]
    y = x
    y is x # True
    y.append(4)
    y is x # True
    print(x, y) # [1,2,4,4] [1,2,3,4]
    
Так же важно различать операторы `=` и `+=`, применяемых к  mutable:

    x = [1,2,3]
    y = x
    y += [5]
    x is y # True. x и y ссылаются на один объект
    z = x + [5]
    x is z # False. Был создан новый объект, на который ссылается z
    
  
## Функции. Общее
Функции также являются объектами.

    def fun_name(arg1, arg2): # (1)
        return arg1+arg2 # (3)(4)
        
    x = fun_name(8,2) # (2)
    y = fun_name(x, 21)
    
(1) При объявлении функции создаётся объект с которым связывается имя функции fun_name.

(2) Создаются объекты 8 и 2 на которые ссылаются arg1 и arg2.

(3) Создаётся объект с результатом - 10.

(4) Ссылка на этот объект - результат выполнения функции. При этом важно, что если функция не имеет явного `return`, то результатом будет `None`.


**Важно** Если заданы аргументы по-умолчанию, то они будут вычислены 1 раз - при объявлении функции:
    
    b = 1
    def foo(a=b):
        print(a)
        
    foo() # out: 1
    b = 2
    foo() # out: 1
    
Здесь дважды вызывается один и тот же mutable list, созданный при объявлении функции:
    
    def foo(x=[0]):
        x[0] += 1
        print(x)
        
    foo() # out 1
    foo() # out 2


##  Стек вызовов
Каждая вызываемая функция помещается в стек вызовов, который работает по принципу LIFO. В основе стека всегда лежит `module` - функция, исполняющая запросы, создающая объекты. 

Все функции "выполняются", но ожидают завершения вышележащей функции.

Для примера:

    def h():
        print(42)
        
    def f():
        g(h)
        
    def g(a):
        a()
        
    g(f)
    
Стек, на момент вызова print, будет выглядеть: `module -> g() -> f() -> g() -> h() -> print()`


## Функции. Аргументы
Аргументы функциям должны передаваться следующим образом:

    def fun(позиционные элементы,
        позиционные аргументы со стандартным значением,
        кортеж элементов (*args),
        keyword_only,
        словарь аргументов (**kwargs))
        
За счёт `*args` и `**kwargs` можно передавать неопределённое количество аргументов. Все позиционные аргументы "уйдут" в кортеж `*args`, а именованные в словарь `**kwargs`. 

При вызове функций можно передавать все значения кортежа и словаря:

    def foo(a, b, *args, c=10):
        print (a, b, c, args) # 1 2 10 (100, 200, 300)
        
    tip = (100, 200, 300)
    foo(1, 2,*tip, c=10)


## Пространство имён (namespaces)
Это множество ссылок от имён до объектов.

При запуске интерпретатора создаётся пространство имён **buitins**, где находятся стандартные имена Python (int, str, max, pow и тд).

Ниже по иерархии расположено пространство имён **main**, в котором определены все глобальные переменные.

Когда вызывается функция - создаётся локальное пространство имён. После завершения функции он уничтожается. Имена в области функции и глобальной могут повторяться:

    t_c = 18
    tmp = 'OK'
    def calc(t_c):
        tmp = t_c*9/5
        return tmp+32
        
    print(calc(t_c)) # 64,4 (1)
    print(tmp) # OK
    
Важно отметить, что в (1) в стек вызовов попадает сначала `calc`, а затем `print`.


##  Области видимости (Scopes)
Правило для поиска имён LEGB: local -> enclosing -> global -> builtins
local - внутри функции
enclosing - до последних закрывающих функций. Т.е. если имеем несколько вложений функций друг в друга, то enclosing дойдёт до самого верхнего уровня:

    def a():
    val = 42
    def b():
        def c():
            def d():
                print(val)
            d()
        c()
    b()
    
    a()
    
Чтобы не париться из-за scope можно передавать переменные в качестве аргументов.
**Важно** переменные, объявленные в цикле в функции, остаются доступны в функции и после завершения цикла.

Локальная переменная, созданная при вызове функции, ссылается на не инициализированную саму себя:

    value = 100
    def foo():
        value = value + 10
        print(value)
        
    foo() # Error
    
Пример правильной работы:

    value = 100
    def foo():
        loc_value = value + 10
        print(loc_value)
        
    foo() # 110
    print(value) # 100
    
Ещё один. Здесь локальная value инициализируется за счёт передачи аргумента:

    value = 100
    def foo(value):
        value = value + 10
        print(value)
        
    foo(value) # 110
    print(value) # 100
    
Пример того, как в теле функции можно изменить глобальную переменную. **ПЛОХОЙ ПОДХОД!**

    value = 100
    def foo():
        global value = value + 10
        print(value)
        
    foo(value) # 110
    print(value) # 110

В чём разница между пространством имён и областью видимостью? Scopes определяет области, откуда доступны определённые имена. Scopes реализован через словарь, сопоставляющий имена с объектами. Эти словари и являются namespaces.


##  Классы. Общее
Класс - механизм создания собственного типа данных.

В отличии от функций, тело класса исполняется в момент его определения. В этот же момент создаётся его namespace.

В классе существуют атрибуты - имена, к которым можно обратиться через `.`. Атрибуты можно добавлять в течение жизненного цикла:

     class Counter:
        pass
        
     x = Counter()
     x.count = 0
     x.count += 1
     
## Классы. Конструктор

    class Counter:
        def __init__(self): # (1)(2)(3)
            self.count = 0
            
    x = Counter() # (4)
    print(x.count) # 0

(1) При определении класса создаётся пустой объект класса (без атрибутов, namespace пуст). 

(2) Этот объект передаётся как `self` в конструктор `__init__`.

(3) `__init__` возвращает `None`, т.к. эта функция призвана устанавливать атрибуты для объекта `self`.

(4) Таким образом, `x` ссылается на изменённый внутри конструктора `self`.

## Классы. Связанные методы
Пример:

    class Counter:  #(1)
        def __init__(self):
            self.count = 0    
            
        def inc(self):
            self.count += 1
            
        def reset(self):
            self.count = 0
            
    x = Counter() # (2)
    x.inc() # (3)
    
(1) При определении класса `Counter` создаётся namespace (`__init__`, `inc`, `reset`)

(2) Объекту `x`, в результате работы конструктора, был добавлен атрибут `count` в namespace. 

(3) В namespace `x` нет имени `inc`, но есть в классе. Как же экземпляр `x` получает доступ к нему? Дело в том, что `x.inc()` - связанный метод, т.е. специальный объект, связывающий объект с функцией класса. Запись `x.inc() == Counter.inc(x)` говорит о том, что `Counter.inc(x)` связалась с `x`.  
